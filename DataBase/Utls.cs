// Decompiled with JetBrains decompiler
// Type: DataBase.Utls
// Assembly: SQLi Dumper, Version=8.5.0.0, Culture=neutral, PublicKeyToken=null
// MVID: FFDD07D3-5737-4188-BACA-DE2D004C7CCF
// Assembly location: C:\Users\cole\Desktop\SQLi Dumper v8.5 [VeryClean]\SQLi v.8.5 VeryClean by Stephanny.exe

using Microsoft.VisualBasic;
using Microsoft.VisualBasic.CompilerServices;
using System.Collections.Generic;
using System.Text;

namespace DataBase
{
  [StandardModule]
  internal sealed class Utls
  {
    public const int NULL_CHAR = 32;
    public const bool EXCLUDE_SYSTEM_SCHEMA = true;

    public static Types CheckSyntaxError(string sSource)
    {
      sSource = sSource.ToLower();
      bool flag = true;
      if (sSource.IndexOf("mysql_num_rows()".ToLower()) >= 0 || flag == sSource.IndexOf("mysql_fetch_array()".ToLower()) >= 0 || (flag == sSource.IndexOf("mysql_result()".ToLower()) >= 0 || flag == sSource.IndexOf("mysql_query()".ToLower()) >= 0) || (flag == sSource.IndexOf("mysql_fetch_assoc()".ToLower()) >= 0 || flag == sSource.IndexOf("mysql_numrows()".ToLower()) >= 0 || (flag == sSource.IndexOf("mysql_fetch_row()".ToLower()) >= 0 || flag == sSource.IndexOf("mysql_fetch_object()".ToLower()) >= 0)) || (flag == sSource.IndexOf("JDBC MySQL()".ToLower()) >= 0 || flag == sSource.IndexOf("MySQL Driver".ToLower()) >= 0 || (flag == sSource.IndexOf("MySQL Error".ToLower()) >= 0 || flag == sSource.IndexOf("MySQL ODBC".ToLower()) >= 0) || (flag == sSource.IndexOf("on MySQL result index".ToLower()) >= 0 || flag == sSource.IndexOf("supplied argument is not a valid MySQL result resource".ToLower()) >= 0 || flag == sSource.IndexOf("MySQL server version for the right syntax to use near".ToLower()) >= 0)))
        return Types.MySQL_Unknown;
      if (flag == sSource.IndexOf("Microsoft OLE DB Provider for ODBC Drivers error".ToLower()) >= 0 || flag == sSource.IndexOf("[Microsoft][ODBC SQL Server Driver][SQL Server]".ToLower()) >= 0 || (flag == sSource.IndexOf("ODBC Drivers error '80040e14'".ToLower()) >= 0 || flag == sSource.IndexOf("ODBC SQL Server Driver".ToLower()) >= 0) || (flag == sSource.IndexOf("JDBC SQL".ToLower()) >= 0 || flag == sSource.IndexOf("Microsoft OLE DB Provider for SQL Server".ToLower()) >= 0 || (flag == sSource.IndexOf("Unclosed quotation mark".ToLower()) >= 0 || flag == sSource.IndexOf("VBScript Runtime".ToLower()) >= 0)) || flag == sSource.IndexOf("SQLServer JDBC Driver".ToLower()) >= 0)
        return Types.MSSQL_Unknown;
      if (flag == sSource.IndexOf("ORA-0".ToLower()) >= 0 || flag == sSource.IndexOf("ORA-1".ToLower()) >= 0 || (flag == sSource.IndexOf("Oracle DB2".ToLower()) >= 0 || flag == sSource.IndexOf("Oracle Driver".ToLower()) >= 0) || (flag == sSource.IndexOf("Oracle Error".ToLower()) >= 0 || flag == sSource.IndexOf("Oracle ODBC".ToLower()) >= 0 || (flag == sSource.IndexOf("MM_XSLTransform error".ToLower()) >= 0 || flag == sSource.IndexOf("[Macromedia][Oracle JDBC Driver][Oracle]ORA-".ToLower()) >= 0)))
        return Types.Oracle_Unknown;
      if (flag == (sSource.IndexOf("[Microsoft][ODBC Microsoft Access Driver]".ToLower()) >= 0 & sSource.IndexOf("WHERE".ToLower()) <= 0) || flag == (sSource.IndexOf("ODBC Microsoft Access Driver".ToLower()) >= 0 & sSource.IndexOf("WHERE".ToLower()) <= 0) || flag == sSource.IndexOf("Microsoft JET Database Engine error '80040e14'".ToLower()) >= 0)
        return Types.MsAccess;
      if (flag == sSource.IndexOf("Warning: pg_exec() ".ToLower()) >= 0 || flag == sSource.IndexOf("function.pg-exec".ToLower()) >= 0 || (flag == sSource.IndexOf("target_user:target_db:PostgreSQL".ToLower()) >= 0 || flag == sSource.IndexOf("PostgreSQL query failed".ToLower()) >= 0) || (flag == sSource.IndexOf("Supplied argument is not a valid PostgreSQL result".ToLower()) >= 0 || flag == sSource.IndexOf("pg_fetch_array()".ToLower()) >= 0 || (flag == sSource.IndexOf("pg_query()".ToLower()) >= 0 || flag == sSource.IndexOf("pg_fetch_assoc()".ToLower()) >= 0)) || flag == sSource.IndexOf("function.pg-query".ToLower()) >= 0)
        return Types.PostgreSQL_Unknown;
      if (flag == sSource.IndexOf("com.sybase.jdbc2.jdbc.SybSQLException".ToLower()) >= 0 || flag == sSource.IndexOf("SybSQLException".ToLower()) >= 0)
        return Types.Sybase;
      return flag != sSource.IndexOf("Error Executing Database Query".ToLower()) >= 0 && flag != sSource.IndexOf("ADODB.Command".ToLower()) >= 0 && (flag != sSource.IndexOf("BOF or EOF".ToLower()) >= 0 && flag != sSource.IndexOf("ADODB.Field".ToLower()) >= 0) && (flag != sSource.IndexOf("sql error".ToLower()) >= 0 && flag != sSource.IndexOf("syntax error".ToLower()) >= 0 && (flag != sSource.IndexOf("OLE DB Provider for ODBC".ToLower()) >= 0 && flag != sSource.IndexOf("ADODBCommand".ToLower()) >= 0)) && (flag != sSource.IndexOf("ADODBField".ToLower()) >= 0 && flag != sSource.IndexOf("A syntax error has occurred".ToLower()) >= 0 && (flag != sSource.IndexOf("Custom Error Message".ToLower()) >= 0 && flag != sSource.IndexOf("Incorrect syntax near".ToLower()) >= 0) && (flag != sSource.IndexOf("Error Report".ToLower()) >= 0 && flag != sSource.IndexOf("Error converting data type varchar to numeric".ToLower()) >= 0 && (flag != sSource.IndexOf("Incorrect syntax near".ToLower()) >= 0 && flag != sSource.IndexOf("SQL command not properly ended".ToLower()) >= 0))) && (flag != sSource.IndexOf("Types mismatch".ToLower()) >= 0 && flag != sSource.IndexOf("invalid query".ToLower()) >= 0 && (flag != sSource.IndexOf("unexpected end of SQL command".ToLower()) >= 0 && flag != sSource.IndexOf("Unclosed quotation mark before the character string".ToLower()) >= 0) && (flag != sSource.IndexOf("Unterminated string constant".ToLower()) >= 0 && flag != sSource.IndexOf("SQLException".ToLower()) >= 0 && flag != sSource.IndexOf("DBObject::doQuery".ToLower()) >= 0)) ? Types.None : Types.Unknown;
    }

    public static string GetMySQLCollaction(MySQLCollactions c)
    {
      string str = "";
      switch (c)
      {
        case MySQLCollactions.None:
          str = "#";
          break;
        case MySQLCollactions.UnHex:
          str = "unhex(hex(#))";
          break;
        case MySQLCollactions.Binary:
          str = "binary(#)";
          break;
        case MySQLCollactions.CastAsChar:
          str = "cast(# as char)";
          break;
        case MySQLCollactions.Compress:
          str = "uncompress(compress(#))";
          break;
        case MySQLCollactions.ConvertUtf8:
          str = "convert(# using utf8)";
          break;
        case MySQLCollactions.ConvertLatin1:
          str = "convert(# using latin1)";
          break;
        case MySQLCollactions.Aes_descrypt:
          str = "aes_decrypt(aes_encrypt(#,1),1)";
          break;
      }
      return str;
    }

    public static string TypeToString(Types o)
    {
      switch (o)
      {
        case Types.MySQL_Unknown:
          return "MySQL";
        case Types.MySQL_No_Error:
          return "MySQL Union";
        case Types.MySQL_With_Error:
          return "MySQL Error";
        case Types.MSSQL_Unknown:
          return "MS SQL";
        case Types.MSSQL_No_Error:
          return "MS SQL Union";
        case Types.MSSQL_With_Error:
          return "MS SQL Error";
        case Types.Oracle_Unknown:
          return "Oracle";
        case Types.Oracle_No_Error:
          return "Oracle Union";
        case Types.Oracle_With_Error:
          return "Oracle Error";
        case Types.PostgreSQL_Unknown:
          return "PostgreSQL";
        case Types.PostgreSQL_No_Error:
          return "PostgreSQL Union";
        case Types.PostgreSQL_With_Error:
          return "PostgreSQL Error";
        case Types.MsAccess:
          return "MS Access";
        case Types.Sybase:
          return "Sybase";
        default:
          return "Unknown";
      }
    }

    public static Types StringToType(string s)
    {
      string Left = s;
      if (Operators.CompareString(Left, "MySQL Unknown", false) == 0 || Operators.CompareString(Left, "MySQL", false) == 0)
        return Types.MySQL_Unknown;
      if (Operators.CompareString(Left, "MySQL Union", false) == 0)
        return Types.MySQL_No_Error;
      if (Operators.CompareString(Left, "MySQL Error", false) == 0)
        return Types.MySQL_With_Error;
      if (Operators.CompareString(Left, "MS SQL Unknown", false) == 0 || Operators.CompareString(Left, "MS SQL", false) == 0)
        return Types.MSSQL_Unknown;
      if (Operators.CompareString(Left, "MS SQL Union", false) == 0)
        return Types.MSSQL_No_Error;
      if (Operators.CompareString(Left, "MS SQL Error", false) == 0)
        return Types.MSSQL_With_Error;
      if (Operators.CompareString(Left, "Oracle Unknown", false) == 0 || Operators.CompareString(Left, "Oracle", false) == 0)
        return Types.Oracle_Unknown;
      if (Operators.CompareString(Left, "Oracle Union", false) == 0)
        return Types.Oracle_No_Error;
      if (Operators.CompareString(Left, "Oracle Error", false) == 0)
        return Types.Oracle_With_Error;
      if (Operators.CompareString(Left, "PostgreSQL Unknown", false) == 0 || Operators.CompareString(Left, "PostgreSQL", false) == 0)
        return Types.PostgreSQL_Unknown;
      if (Operators.CompareString(Left, "PostgreSQL Union", false) == 0)
        return Types.PostgreSQL_No_Error;
      if (Operators.CompareString(Left, "PostgreSQL Error", false) == 0)
        return Types.PostgreSQL_With_Error;
      if (Operators.CompareString(Left, "MS Access", false) == 0)
        return Types.MsAccess;
      return Operators.CompareString(Left, "Sybase", false) == 0 ? Types.Sybase : Types.Unknown;
    }

    public static string BuilListMySQL(
      List<string> o,
      bool bUnhexHex = false,
      bool bCastAsChar = false,
      bool bHexEncoded = false,
      bool bConvertUtf8 = false)
    {
      Conversions.ToString(Interaction.IIf(bConvertUtf8, (object) "convert(# using utf8)", (object) "#"));
      string newValue1 = Conversions.ToString(Interaction.IIf(bUnhexHex, (object) "unhex(hex(#))", (object) "#"));
      string newValue2 = Conversions.ToString(Interaction.IIf(bHexEncoded, (object) "hex(#)", (object) "#"));
      string newValue3 = Conversions.ToString(Interaction.IIf(bCastAsChar, (object) "cast(# as char)", (object) "#"));
      StringBuilder stringBuilder = new StringBuilder();
      int num1 = checked (o.Count - 1);
      int index = 0;
      while (index <= num1)
      {
        string str = o[index].Replace("#", Conversions.ToString(bConvertUtf8)).Replace("#", newValue2).Replace("#", newValue1).Replace("#", newValue3);
        int num2 = index;
        if (num2 == 0)
          stringBuilder.Append(str);
        else if (num2 == checked (o.Count - 1))
          stringBuilder.Append(str);
        else
          stringBuilder.Append("," + str);
        checked { ++index; }
      }
      return stringBuilder.ToString();
    }

    public static string BuilListForWhereIn(
      List<string> o,
      bool bHex,
      bool bSQLChar = false,
      bool bGroupChar = true)
    {
      StringBuilder stringBuilder = new StringBuilder();
      int num1 = checked (o.Count - 1);
      int index = 0;
      while (index <= num1)
      {
        string str = !bHex ? Globals.G_Utilities.ConvertTextToSQLChar(o[index], bGroupChar) : Globals.G_Utilities.ConvertTextToHex(o[index]);
        int num2 = index;
        if (num2 == 0)
          stringBuilder.Append(str);
        else if (num2 == checked (o.Count - 1))
          stringBuilder.Append(str);
        else
          stringBuilder.Append("," + str);
        checked { ++index; }
      }
      return stringBuilder.ToString();
    }

    public static bool TypeIsMySQL(Types t) => t == Types.MySQL_No_Error | t == Types.MySQL_With_Error | t == Types.MySQL_Unknown;

    public static bool TypeIsMSSQL(Types t) => t == Types.MSSQL_No_Error | t == Types.MSSQL_With_Error | t == Types.MSSQL_Unknown;

    public static bool TypeIsOracle(Types t) => t == Types.Oracle_No_Error | t == Types.Oracle_With_Error | t == Types.Oracle_Unknown;

    public static bool TypeIsPostgreSQL(Types t) => t == Types.PostgreSQL_No_Error | t == Types.PostgreSQL_With_Error | t == Types.PostgreSQL_Unknown;

    public static bool TypeIsError(Types t) => t == Types.MySQL_With_Error | t == Types.MSSQL_With_Error | t == Types.Oracle_With_Error | t == Types.PostgreSQL_With_Error;

    public static bool TypeIsInjecatble(Types t) => (uint) (-(t == Types.MySQL_With_Error ? 1 : 0) | 3 | -(t == Types.MSSQL_With_Error ? 1 : 0) | 6 | -(t == Types.Oracle_With_Error ? 1 : 0) | 9 | -(t == Types.PostgreSQL_With_Error ? 1 : 0) | 12) > 0U;
  }
}
