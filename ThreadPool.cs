// Decompiled with JetBrains decompiler
// Type: ThreadPool
// Assembly: SQLi Dumper, Version=8.5.0.0, Culture=neutral, PublicKeyToken=null
// MVID: FFDD07D3-5737-4188-BACA-DE2D004C7CCF
// Assembly location: C:\Users\cole\Desktop\SQLi Dumper v8.5 [VeryClean]\SQLi v.8.5 VeryClean by Stephanny.exe

using Microsoft.VisualBasic.CompilerServices;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Windows.Forms;

public class ThreadPool
{
  private object __CountLock;
  private object __PushLock;
  private bool __AllPushed;
  private int __MaxThreadCount;
  private ThreadPool.ThreadStatus __Status;
  private List<Thread> __ActiveThreads;

  public event ThreadPool.OnStartedEventHandler OnStarted;

  public event ThreadPool.OnFinishedEventHandler OnFinished;

  public ThreadPool(int maxThreadCount)
  {
    this.__CountLock = RuntimeHelpers.GetObjectValue(new object());
    this.__PushLock = RuntimeHelpers.GetObjectValue(new object());
    this.MaxThreadCount = maxThreadCount;
    if (this.MaxThreadCount <= 0)
      this.MaxThreadCount = 1;
    this.__ActiveThreads = new List<Thread>(this.MaxThreadCount);
    ThreadPool.OnStartedEventHandler onStartedEvent = this.OnStartedEvent;
    if (onStartedEvent == null)
      return;
    onStartedEvent();
  }

  public int ThreadCount
  {
    get
    {
      int num1;
      int count;
      int num2;
      while (true)
      {
        try
        {
label_1:
          ProjectData.ClearProjectError();
          num1 = 1;
label_2:
          int num3 = 2;
          List<Thread>.Enumerator enumerator = this.__ActiveThreads.GetEnumerator();
label_3:
          Thread current;
          if (enumerator.MoveNext())
          {
            current = enumerator.Current;
          }
          else
          {
            enumerator.Dispose();
            goto label_9;
          }
label_5:
          num3 = 3;
          if (current.ThreadState != ThreadState.Stopped)
            goto label_7;
label_6:
          num3 = 4;
          this.Close(current);
          continue;
label_7:
          num3 = 7;
          goto label_3;
label_9:
          num3 = 8;
          count = this.__ActiveThreads.Count;
          goto label_16;
label_11:
          num2 = num3;
          switch (num1)
          {
            case 1:
              int num4 = num2 + 1;
              num2 = 0;
              switch (num4)
              {
                case 1:
                  goto label_1;
                case 2:
                  goto label_2;
                case 3:
                  goto label_5;
                case 4:
                  goto label_6;
                case 5:
                  continue;
                case 6:
                case 7:
                  goto label_7;
                case 8:
                  goto label_9;
                case 9:
                  goto label_16;
                default:
                  goto label_15;
              }
            default:
              goto label_15;
          }
        }
        catch (Exception ex) when (ex is Exception & (uint) num1 > 0U & num2 == 0)
        {
          ProjectData.SetProjectError(ex);
          goto label_11;
        }
      }
label_15:
      throw ProjectData.CreateProjectError(-2146828237);
label_16:
      int num5 = count;
      if (num2 == 0)
        return num5;
      ProjectData.ClearProjectError();
      return num5;
    }
  }

  public int MaxThreadCount
  {
    get => this.__MaxThreadCount;
    set => this.__MaxThreadCount = value;
  }

  public bool Finished => this.AllPushed && this.ThreadCount <= 0;

  public ThreadPool.ThreadStatus Status
  {
    get => this.__Status;
    set => this.__Status = value;
  }

  private bool AllPushed
  {
    get
    {
      object pushLock = this.__PushLock;
      ObjectFlowControl.CheckForSyncLockOnValueType(pushLock);
      bool lockTaken = false;
      try
      {
        Monitor.Enter(pushLock, ref lockTaken);
        return this.__AllPushed | this.Status == ThreadPool.ThreadStatus.Stopped;
      }
      finally
      {
        if (lockTaken)
          Monitor.Exit(pushLock);
      }
    }
  }

  public bool Paused
  {
    get
    {
      bool flag;
      return !this.Finished ? this.__Status == ThreadPool.ThreadStatus.Paused : flag;
    }
    set
    {
      if (this.Finished)
        return;
      if (value)
        this.__Status = ThreadPool.ThreadStatus.Paused;
      else
        this.__Status = ThreadPool.ThreadStatus.Started;
    }
  }

  public void Open(Thread thread = null)
  {
    if (thread == null)
      return;
    this.__ActiveThreads.Add(thread);
  }

  public void AllJobsPushed()
  {
    object pushLock = this.__PushLock;
    ObjectFlowControl.CheckForSyncLockOnValueType(pushLock);
    bool lockTaken = false;
    try
    {
      Monitor.Enter(pushLock, ref lockTaken);
      this.__AllPushed = true;
      if (!this.Finished)
        return;
      ThreadPool.OnFinishedEventHandler onFinishedEvent = this.OnFinishedEvent;
      if (onFinishedEvent == null)
        return;
      onFinishedEvent();
    }
    finally
    {
      if (lockTaken)
        Monitor.Exit(pushLock);
    }
  }

  public void Close(Thread thread = null)
  {
label_0:
    int num1;
    int num2;
    try
    {
      ProjectData.ClearProjectError();
      num1 = 1;
label_1:
      int num3 = 2;
      if (!this.__ActiveThreads.Contains(thread))
        goto label_9;
label_2:
      num3 = 3;
      this.__ActiveThreads.Remove(thread);
      goto label_9;
label_4:
      num2 = num3;
      switch (num1)
      {
        case 1:
          int num4 = num2 + 1;
          num2 = 0;
          switch (num4)
          {
            case 1:
              goto label_0;
            case 2:
              goto label_1;
            case 3:
              goto label_2;
            case 4:
            case 5:
              goto label_9;
          }
          break;
      }
    }
    catch (Exception ex) when (ex is Exception & (uint) num1 > 0U & num2 == 0)
    {
      ProjectData.SetProjectError(ex);
      goto label_4;
    }
    throw ProjectData.CreateProjectError(-2146828237);
label_9:
    if (num2 == 0)
      return;
    ProjectData.ClearProjectError();
  }

  public void WaitForThreads()
  {
    while ((this.ThreadCount >= this.MaxThreadCount || this.Status == ThreadPool.ThreadStatus.Paused) && this.Status != ThreadPool.ThreadStatus.Stopped)
    {
      Thread.Sleep(100);
      Application.DoEvents();
    }
  }

  public bool FreeSlot() => this.ThreadCount < this.MaxThreadCount;

  public void AbortThreads()
  {
label_0:
    int num1;
    int num2;
    try
    {
      ProjectData.ClearProjectError();
      num1 = 1;
label_4:
      int num3 = 3;
      if (this.__ActiveThreads.Count <= 0)
        goto label_5;
label_1:
      num3 = 4;
      Thread activeThread = this.__ActiveThreads[0];
label_2:
      num3 = 5;
      activeThread.Abort();
label_3:
      num3 = 6;
      this.__ActiveThreads.Remove(activeThread);
      goto label_4;
label_5:
      num3 = 8;
      this.Status = ThreadPool.ThreadStatus.Stopped;
label_6:
      num3 = 9;
      this.__AllPushed = true;
label_7:
      num3 = 10;
      this.__ActiveThreads.Clear();
      goto label_14;
label_9:
      num2 = num3;
      switch (num1)
      {
        case 1:
          int num4 = num2 + 1;
          num2 = 0;
          switch (num4)
          {
            case 1:
              goto label_0;
            case 2:
            case 3:
            case 7:
              goto label_4;
            case 4:
              goto label_1;
            case 5:
              goto label_2;
            case 6:
              goto label_3;
            case 8:
              goto label_5;
            case 9:
              goto label_6;
            case 10:
              goto label_7;
            case 11:
              goto label_14;
          }
          break;
      }
    }
    catch (Exception ex) when (ex is Exception & (uint) num1 > 0U & num2 == 0)
    {
      ProjectData.SetProjectError(ex);
      goto label_9;
    }
    throw ProjectData.CreateProjectError(-2146828237);
label_14:
    if (num2 == 0)
      return;
    ProjectData.ClearProjectError();
  }

  public enum ThreadStatus
  {
    Started,
    Stopped,
    Paused,
  }

  public delegate void OnStartedEventHandler();

  public delegate void OnFinishedEventHandler();
}
